/**
 * Copyright (C) 2011 Adriano Monteiro Marques
 *
 * Author: ICM Team
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA
 */


package org.umit.icm.mobile.proto;
option java_outer_classname = "MessageProtos";

//package org.umit.icm.proto.java;

message Trace {
	required int32 hop = 1;
	required string ip = 2;
	repeated int32 packetsTiming = 3; // The timing for each packet sent to that node
}

message TraceRoute {
	required string target = 1; // The target may have multiple IP addresses. This field holds the IP of the one used for the trace
	required int32 hops = 2;
	required int32 packetSize = 3;
	repeated Trace traces = 4;
}

message ICMReport {
	required string reportID = 1;
	required int64 agentID = 2;
	required int32 testID = 3;
	required int32 timeZone = 4;
	required int64 timeUTC = 5;
	repeated string passedNode = 6;
	optional TraceRoute traceroute = 7;
}

message WebsiteReportDetail {
	required string websiteURL = 1;
	required int32 statusCode = 2;
	optional int32 responseTime = 3;
	optional int32 bandwidth = 4;
	optional string redirectLink = 5;
	optional string htmlResponse = 6;
	optional bytes htmlMedia = 7; // If not in mobile agent, then grab the media files and pack them with gzip and store it in this field.
}

message WebsiteReport {
	required ICMReport header = 1;
	required WebsiteReportDetail report = 2;
}

message ServiceReportDetail {
	required string serviceName = 1;
	required int32 statusCode = 2;
	optional double responseTime = 3;
	optional double bandwidth = 4;
}

message ServiceReport {
	required ICMReport header = 1;
	required ServiceReportDetail report = 2;
}

// Webservice Response Messages

// Request Header
message RequestHeader {
	required string token = 1;
	required int64 agentID = 2;
}

// Response Header
message ResponseHeader {
	required int32 currentVersionNo = 1;
	required int32 currentTestVersionNo = 2; // The version of the current set of tests
}

// agent_connect/register_peer

message RegisterAgent {
	required string ip = 1;
	required int32 versionNo = 2;
}

message RegisterAgentResponse {
	required ResponseHeader header = 1;
	required string token = 2;
	required string privateKey = 3;
	required string publicKey = 4;
	required int64 agentID = 5;
	required string cipheredPublicKey = 6;
	required string aggregatorPublicKey = 7;
}

// get_peers_list

message GetPeerList {
	required RequestHeader header = 1;
}

message AgentData {
	required int64 agentID = 1;
	required string agentIP = 2;
	required int32 agentPort = 3;
	required string token = 4;
	required string publicKey = 5;
	required string peerStatus = 6; // Can be ON, OFF or UNKNOWN
}

message GetPeerListResponse {
	required ResponseHeader header = 1;
	repeated AgentData knownPeers = 2;
}

// get_super_peers_list

message GetSuperPeerList {
	required RequestHeader header = 1;
}

message GetSuperPeerListResponse {
	required ResponseHeader header = 1;
	repeated AgentData knownSuperPeers = 2;
}

// get_events

message GetEvents {
	required RequestHeader header = 1;
	repeated string locations = 2; // A list of geo areas that we might be covering with reports.
	optional int64 geoLat = 3;
	optional int64 geoLon = 4;
}

message Event {
	required string testType = 1; // Identifier for the type of test taken (WEB or SERVICE for now)
	required string eventType = 2; // The sort of event: CENSOR, THROTTLING, OFF_LINE
	required int64 timeUTC = 3; // Actual time
	required int64 sinceTimeUTC = 4; // Time since when this event was first noticed
	repeated string locations = 5; // A list of geo areas that we might be covering with reports.
	optional WebsiteReportDetail websiteReport = 6;
	optional ServiceReportDetail serviceReport = 7;
}

message GetEventsResponse {
	required ResponseHeader header = 1;
	repeated Event events = 2;
}

// send_report
message SendWebsiteReport {
	required RequestHeader header = 1;
	required WebsiteReport report = 2;
}

message SendServiceReport {
	required RequestHeader header = 1;
	required ServiceReport report = 2;
}

message SendReportResponse {
	required ResponseHeader header = 1;
}

// new_version_available

message NewVersion {
	required RequestHeader header = 1;
	required int32 agentVersionNo = 2;
	required string agentType = 3; // Right now can be MOBILE or DESKTOP
}

message NewVersionResponse {
	required ResponseHeader header = 1;
	optional string downloadURL = 2;
	optional bytes update = 3; // The binary update in bzip2 format. Patch should be fine.
	required int32 versionNo = 4; // The new version number.
}

// new_tests_available

message NewTests {
	required RequestHeader header = 1;
	required int32 currentTestVersionNo = 2;
}

message Test {
	required int64 testID = 1;
	optional string websiteURL = 2;
	optional int32 servideCode = 3;
	optional int64 executeAtTimeUTC = 4;
	required string testType = 5; // Identifier for the type of test taken (WEB or SERVICE for now)
}

message NewTestsResponse {
	required ResponseHeader header = 1;
	repeated Test tests = 2; // tests will only contain anything if the version of the NewTests message is lower than current version
	required int32 testVersionNo = 3; // The new test version number.
}

// assign_tasks_to_peer

message AssignTask {
	required RequestHeader header = 1;
}

message AssignTaskResponse {
	required ResponseHeader header = 1;
	repeated Test tests = 2;
}

// upgrade_peer_to_be_super

message UpgradeToSuper {
	required RequestHeader header = 1;
}

message UpgradeToSuperResponse {
	required ResponseHeader header = 1;
	required string newToken = 2;
	required string newPrivateKey = 3;
	required string newPublicKey = 4;
}

// send_private_key

message SendPrivateKey {
	required RequestHeader header = 1;
	required string symmetricPrivateKey = 2;
}

message SendPrivateKeyResponse {
	required ResponseHeader header = 1;
}

message WebsiteSuggestion {
	required RequestHeader header = 1;
	required string websiteURL = 2;
	optional string emailAddress = 3;
}

message ServiceSuggestion {
	required RequestHeader header = 1;
	required string serviceName = 2;
	optional string emailAddress = 3;
	required string hostName = 4;
	required string ip = 5;
}

message TestSuggestionResponse {
	required ResponseHeader header = 1;
}

message AuthenticatePeer {
	required int32 agentType = 1;	
	required int64 agentID = 2;	
	required string cipheredPublicKey = 3;
	optional int32 agentPort = 4;
}

message AuthenticatePeerResponse {
	required string secretKey = 1;
}

message P2PGetSuperPeerList {
	required int32 count = 1;
}

message P2PGetSuperPeerListResponse {
	repeated AgentData peers = 1;
}

message P2PGetPeerList {
	required int32 count = 1;
}

message P2PGetPeerListResponse {
	repeated AgentData peers = 1;
}

message AgentUpdate {
	required string version = 1;
	required string downloadURL = 2;
	optional int32 checkCode = 3;
}

message AgentUpdateResponse {
	required string version = 1;
	required string result = 2;
}

message TestModuleUpdate {
	required string version = 1;
	required string downloadURL = 2;
	optional int32 checkCode = 3;
}

message TestModuleUpdateResponse {
	required string version = 1;
	required string result = 2;
}
